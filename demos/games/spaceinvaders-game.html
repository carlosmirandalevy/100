<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
<title>Space Invaders</title>
<style>
*{margin:0;padding:0;box-sizing:border-box}
html,body{width:100%;height:100%;overflow:hidden;background:#000;touch-action:none;user-select:none;-webkit-user-select:none}
#wrap{position:relative;width:100%;height:100%;display:flex;align-items:center;justify-content:center}
canvas{display:block;background:#000}
.btn{position:absolute;border:2px solid rgba(255,255,255,0.3);border-radius:50%;display:flex;align-items:center;justify-content:center;opacity:0.35;transition:opacity 0.1s;cursor:pointer;z-index:10;-webkit-tap-highlight-color:transparent}
.btn.active{opacity:0.7}
.btn svg{pointer-events:none}
#btn-left{width:64px;height:64px;bottom:24px;left:16px;border-radius:14px}
#btn-right{width:64px;height:64px;bottom:24px;left:88px;border-radius:14px}
#btn-fire{width:76px;height:76px;bottom:18px;right:16px;background:rgba(220,60,30,0.15);border-color:rgba(220,60,30,0.5)}
#btn-fire.active{background:rgba(220,60,30,0.35)}
</style>
</head>
<body>
<div id="wrap">
  <canvas id="c"></canvas>
  <div class="btn" id="btn-left">
    <svg width="28" height="28" viewBox="0 0 24 24" fill="none" stroke="#fff" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round"><polyline points="15 18 9 12 15 6"/></svg>
  </div>
  <div class="btn" id="btn-right">
    <svg width="28" height="28" viewBox="0 0 24 24" fill="none" stroke="#fff" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round"><polyline points="9 6 15 12 9 18"/></svg>
  </div>
  <div class="btn" id="btn-fire">
    <svg width="32" height="32" viewBox="0 0 24 24" fill="none" stroke="#ff6644" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round"><polygon points="12 2 15 10 22 10 16 15 18 22 12 18 6 22 8 15 2 10 9 10"/></svg>
  </div>
</div>
<script>
(function(){
"use strict";

// ── Canvas setup ──
var canvas = document.getElementById("c");
var ctx = canvas.getContext("2d");
var W, H, SCALE;

function resize(){
  var ww = window.innerWidth, wh = window.innerHeight;
  var maxW = Math.min(480, ww);
  var maxH = wh;
  var ratio = 1.6;
  if(maxW * ratio > maxH){ maxW = maxH / ratio; }
  W = Math.floor(maxW);
  H = Math.floor(W * ratio);
  canvas.width = W;
  canvas.height = H;
  SCALE = W / 480;
}
resize();
window.addEventListener("resize", resize);

// ── Audio (Web Audio API) ──
var audioCtx = null;
function ensureAudio(){ if(!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)(); }

function playTone(freq, dur, type, vol, sweep){
  if(!audioCtx) return;
  var osc = audioCtx.createOscillator();
  var gain = audioCtx.createGain();
  osc.type = type || "square";
  osc.frequency.setValueAtTime(freq, audioCtx.currentTime);
  if(sweep) osc.frequency.exponentialRampToValueAtTime(sweep, audioCtx.currentTime + dur);
  gain.gain.setValueAtTime(vol || 0.12, audioCtx.currentTime);
  gain.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + dur);
  osc.connect(gain);
  gain.connect(audioCtx.destination);
  osc.start(audioCtx.currentTime);
  osc.stop(audioCtx.currentTime + dur);
}

function playNoise(dur, vol){
  if(!audioCtx) return;
  var buf = audioCtx.createBuffer(1, audioCtx.sampleRate * dur, audioCtx.sampleRate);
  var data = buf.getChannelData(0);
  for(var i = 0; i < data.length; i++) data[i] = (Math.random() * 2 - 1);
  var src = audioCtx.createBufferSource();
  src.buffer = buf;
  var gain = audioCtx.createGain();
  gain.gain.setValueAtTime(vol || 0.1, audioCtx.currentTime);
  gain.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + dur);
  src.connect(gain);
  gain.connect(audioCtx.destination);
  src.start();
}

var sfx = {
  shoot: function(){ playTone(880, 0.08, "square", 0.08, 440); },
  enemyHit: function(){ playNoise(0.12, 0.12); },
  playerHit: function(){ playNoise(0.3, 0.18); playTone(120, 0.3, "sawtooth", 0.1, 40); },
  ufoAppear: function(){ playTone(120, 0.12, "sine", 0.15, 180); playTone(180, 0.12, "sine", 0.12, 120); },
  ufoHit: function(){ playTone(400, 0.25, "sine", 0.1, 1200); },
  gameOver: function(){
    playTone(400, 0.2, "square", 0.1, 200);
    setTimeout(function(){ playTone(300, 0.2, "square", 0.1, 150); }, 200);
    setTimeout(function(){ playTone(200, 0.4, "square", 0.1, 80); }, 400);
  },
  newWave: function(){
    playTone(440, 0.1, "square", 0.08, 660);
    setTimeout(function(){ playTone(660, 0.1, "square", 0.08, 880); }, 100);
    setTimeout(function(){ playTone(880, 0.15, "square", 0.08, 1100); }, 200);
  }
};

// ── Input ──
var keys = { left:false, right:false, fire:false, enter:false };

document.addEventListener("keydown", function(e){
  ensureAudio();
  if(e.key==="ArrowLeft"||e.key==="a"||e.key==="A") keys.left=true;
  if(e.key==="ArrowRight"||e.key==="d"||e.key==="D") keys.right=true;
  if(e.key===" "||e.key==="ArrowUp") keys.fire=true;
  if(e.key==="Enter") keys.enter=true;
  if([" ","ArrowUp","ArrowDown","ArrowLeft","ArrowRight"].indexOf(e.key)>=0) e.preventDefault();
});
document.addEventListener("keyup", function(e){
  if(e.key==="ArrowLeft"||e.key==="a"||e.key==="A") keys.left=false;
  if(e.key==="ArrowRight"||e.key==="d"||e.key==="D") keys.right=false;
  if(e.key===" "||e.key==="ArrowUp") keys.fire=false;
  if(e.key==="Enter") keys.enter=false;
});

// Button controls
function bindBtn(id, key){
  var el = document.getElementById(id);
  function on(e){ e.preventDefault(); ensureAudio(); keys[key]=true; el.classList.add("active"); }
  function off(e){ e.preventDefault(); keys[key]=false; el.classList.remove("active"); }
  el.addEventListener("touchstart", on, {passive:false});
  el.addEventListener("touchend", off, {passive:false});
  el.addEventListener("touchcancel", off, {passive:false});
  el.addEventListener("mousedown", on);
  el.addEventListener("mouseup", off);
  el.addEventListener("mouseleave", off);
}
bindBtn("btn-left","left");
bindBtn("btn-right","right");
bindBtn("btn-fire","fire");

// Also treat tap on canvas as enter (for start/restart)
canvas.addEventListener("touchstart", function(e){ ensureAudio(); keys.enter=true; setTimeout(function(){keys.enter=false;},100); }, {passive:true});
canvas.addEventListener("click", function(){ ensureAudio(); keys.enter=true; setTimeout(function(){keys.enter=false;},100); });

// ── Starfield ──
var stars = [];
function initStars(){
  stars = [];
  for(var i=0;i<60;i++) stars.push({x:Math.random()*480, y:Math.random()*768, s:Math.random()*1.5+0.5, b:Math.random()*0.5+0.3});
}
initStars();

function updateStars(dt){
  for(var i=0;i<stars.length;i++){
    stars[i].y += stars[i].s * 20 * dt;
    if(stars[i].y > 768){ stars[i].y=0; stars[i].x=Math.random()*480; }
  }
}
function drawStars(){
  for(var i=0;i<stars.length;i++){
    ctx.fillStyle="rgba(255,255,255,"+stars[i].b+")";
    ctx.fillRect(stars[i].x*SCALE, stars[i].y*SCALE, stars[i].s*SCALE, stars[i].s*SCALE);
  }
}

// ── Game state ──
var STATE_START=0, STATE_PLAYING=1, STATE_OVER=2;
var state = STATE_START;
var score, lives, wave, highScore;
var player, bullets, enemyBullets, enemies, barriers, ufo, particles;
var enemyDir, enemySpeed, enemyBaseSpeed, enemyDropTimer, enemyFireTimer;
var ufoTimer, ufoSfxTimer;
var frameCount;

highScore = parseInt(localStorage.getItem("si_hi")) || 0;

function initGame(){
  score = 0;
  lives = 3;
  wave = 1;
  frameCount = 0;
  initPlayer();
  initEnemies();
  initBarriers();
  bullets = [];
  enemyBullets = [];
  particles = [];
  ufo = null;
  ufoTimer = 25 + Math.random()*10;
  ufoSfxTimer = 0;
}

// ── Player ──
function initPlayer(){
  player = { x:240, y:700, w:32, h:24, speed:200, cooldown:0, invuln:0 };
}

function drawPlayer(px, py, s){
  ctx.save();
  ctx.translate(px*SCALE, py*SCALE);
  ctx.scale(SCALE, SCALE);
  // Ship body
  ctx.fillStyle = "#4f8";
  ctx.beginPath();
  ctx.moveTo(0, -12);
  ctx.lineTo(-14, 12);
  ctx.lineTo(-6, 8);
  ctx.lineTo(-6, 12);
  ctx.lineTo(6, 12);
  ctx.lineTo(6, 8);
  ctx.lineTo(14, 12);
  ctx.closePath();
  ctx.fill();
  // Cockpit
  ctx.fillStyle = "#aff";
  ctx.fillRect(-3, -4, 6, 8);
  // Engines
  ctx.fillStyle = "#f84";
  ctx.fillRect(-10, 10, 4, 4);
  ctx.fillRect(6, 10, 4, 4);
  ctx.restore();
}

// ── Enemies ──
var ECOLS=5, EROWS=4, EW=30, EH=24, EGAPX=42, EGAPY=36;

function initEnemies(){
  enemies = [];
  var startX = 240 - (ECOLS * EGAPX)/2 + EGAPX/2;
  var startY = 80 + Math.min(wave-1, 4) * 20;
  for(var r=0;r<EROWS;r++){
    for(var c=0;c<ECOLS;c++){
      enemies.push({ x:startX+c*EGAPX, y:startY+r*EGAPY, w:EW, h:EH, row:r, alive:true, frame:0 });
    }
  }
  enemyDir = 1;
  enemyBaseSpeed = 30 + wave * 8;
  enemySpeed = enemyBaseSpeed;
  enemyDropTimer = 0;
  enemyFireTimer = 1.5;
}

function drawEnemy(e){
  var cx = e.x * SCALE, cy = e.y * SCALE, s = SCALE;
  var colors = ["#f44","#f84","#ff4","#4ff"];
  ctx.fillStyle = colors[e.row] || "#fff";
  // Pixel-art alien with frame animation
  var f = e.frame;
  ctx.save();
  ctx.translate(cx, cy);
  // Body
  ctx.fillRect(-10*s, -6*s, 20*s, 12*s);
  // Eyes
  ctx.fillStyle="#000";
  ctx.fillRect(-6*s, -4*s, 4*s, 4*s);
  ctx.fillRect(2*s, -4*s, 4*s, 4*s);
  // Pupils
  ctx.fillStyle="#fff";
  ctx.fillRect(-5*s, -3*s, 2*s, 2*s);
  ctx.fillRect(3*s, -3*s, 2*s, 2*s);
  // Legs (alternate)
  ctx.fillStyle = colors[e.row] || "#fff";
  if(f===0){
    ctx.fillRect(-12*s, 6*s, 4*s, 4*s);
    ctx.fillRect(8*s, 6*s, 4*s, 4*s);
    ctx.fillRect(-4*s, 6*s, 3*s, 3*s);
    ctx.fillRect(1*s, 6*s, 3*s, 3*s);
  } else {
    ctx.fillRect(-10*s, 6*s, 4*s, 6*s);
    ctx.fillRect(6*s, 6*s, 4*s, 6*s);
  }
  // Antennae
  ctx.fillRect(-8*s, -10*s, 2*s, 4*s);
  ctx.fillRect(6*s, -10*s, 2*s, 4*s);
  ctx.restore();
}

// ── Barriers ──
function initBarriers(){
  barriers = [];
  var bw = 44, bh = 32, gap = 480/(4+1);
  for(var i=0;i<4;i++){
    var bx = gap*(i+1);
    var by = 620;
    var blocks = [];
    for(var r=0;r<8;r++){
      for(var c=0;c<11;c++){
        // Skip corners to make arch shape
        if(r>=5 && c>=4 && c<=6) continue; // arch opening
        blocks.push({ x:bx-22+c*4, y:by-16+r*4, alive:true });
      }
    }
    barriers.push(blocks);
  }
}

function drawBarriers(){
  ctx.fillStyle="#0f0";
  for(var i=0;i<barriers.length;i++){
    var bl = barriers[i];
    for(var j=0;j<bl.length;j++){
      if(bl[j].alive){
        ctx.fillRect(bl[j].x*SCALE, bl[j].y*SCALE, 4*SCALE, 4*SCALE);
      }
    }
  }
}

// ── UFO ──
function drawUfo(u){
  ctx.save();
  ctx.translate(u.x*SCALE, u.y*SCALE);
  ctx.scale(SCALE,SCALE);
  ctx.fillStyle="#f0f";
  // Dome
  ctx.beginPath();
  ctx.ellipse(0,-4,8,6,0,Math.PI,0);
  ctx.fill();
  // Body
  ctx.fillStyle="#f4f";
  ctx.beginPath();
  ctx.ellipse(0,0,16,6,0,0,Math.PI*2);
  ctx.fill();
  // Lights
  ctx.fillStyle="#ff0";
  ctx.fillRect(-10,0,3,3);
  ctx.fillRect(-2,0,3,3);
  ctx.fillRect(6,0,3,3);
  ctx.restore();
}

// ── Particles ──
function spawnParticles(x,y,color,count){
  for(var i=0;i<count;i++){
    var a = Math.random()*Math.PI*2;
    var sp = Math.random()*120+40;
    particles.push({x:x,y:y,vx:Math.cos(a)*sp,vy:Math.sin(a)*sp,life:0.4+Math.random()*0.3,color:color});
  }
}

// ── Collision ──
function boxHit(ax,ay,aw,ah,bx,by,bw,bh){
  return ax-aw/2<bx+bw/2 && ax+aw/2>bx-bw/2 && ay-ah/2<by+bh/2 && ay+ah/2>by-bh/2;
}

// ── Update ──
function update(dt){
  frameCount++;

  if(state===STATE_START || state===STATE_OVER){
    updateStars(dt);
    if(keys.enter){
      keys.enter=false;
      initGame();
      state=STATE_PLAYING;
    }
    return;
  }

  updateStars(dt);

  // Player movement
  if(player.invuln>0) player.invuln-=dt;
  if(keys.left) player.x -= player.speed*dt;
  if(keys.right) player.x += player.speed*dt;
  if(player.x<20) player.x=20;
  if(player.x>460) player.x=460;

  // Player fire
  player.cooldown -= dt;
  if(keys.fire && player.cooldown<=0 && bullets.length<3){
    bullets.push({x:player.x, y:player.y-16, vy:-400});
    player.cooldown=0.25;
    sfx.shoot();
  }

  // Player bullets
  for(var i=bullets.length-1;i>=0;i--){
    bullets[i].y += bullets[i].vy*dt;
    if(bullets[i].y<0) bullets.splice(i,1);
  }

  // Enemy movement
  var aliveCount = 0;
  var leftMost=480, rightMost=0;
  for(var i=0;i<enemies.length;i++){
    if(!enemies[i].alive) continue;
    aliveCount++;
    if(enemies[i].x<leftMost) leftMost=enemies[i].x;
    if(enemies[i].x>rightMost) rightMost=enemies[i].x;
  }

  if(aliveCount===0){
    // Next wave
    wave++;
    sfx.newWave();
    initEnemies();
    ufo = null;
    ufoTimer = 20 + Math.random()*10;
    return;
  }

  // Speed increases as fewer enemies remain
  enemySpeed = enemyBaseSpeed * (1 + (ECOLS*EROWS - aliveCount)/(ECOLS*EROWS) * 3);

  var needDrop = false;
  if(enemyDir>0 && rightMost+enemySpeed*dt > 460) needDrop=true;
  if(enemyDir<0 && leftMost-enemySpeed*dt < 20) needDrop=true;

  if(needDrop){
    enemyDir *= -1;
    for(var i=0;i<enemies.length;i++){
      if(enemies[i].alive) enemies[i].y += 16;
    }
  } else {
    for(var i=0;i<enemies.length;i++){
      if(enemies[i].alive) enemies[i].x += enemyDir * enemySpeed * dt;
    }
  }

  // Animate enemy frames
  if(frameCount%30===0){
    for(var i=0;i<enemies.length;i++) enemies[i].frame = enemies[i].frame===0?1:0;
  }

  // Enemy fire
  enemyFireTimer -= dt;
  if(enemyFireTimer<=0){
    // Pick a random alive enemy from bottom rows
    var shooters = [];
    for(var c=0;c<ECOLS;c++){
      for(var r=EROWS-1;r>=0;r--){
        var idx = r*ECOLS+c;
        if(enemies[idx] && enemies[idx].alive){ shooters.push(enemies[idx]); break; }
      }
    }
    if(shooters.length>0){
      var s = shooters[Math.floor(Math.random()*shooters.length)];
      enemyBullets.push({x:s.x, y:s.y+12, vy:180+wave*15});
    }
    enemyFireTimer = Math.max(0.4, 1.8 - wave*0.12);
  }

  // Enemy bullets
  for(var i=enemyBullets.length-1;i>=0;i--){
    enemyBullets[i].y += enemyBullets[i].vy*dt;
    if(enemyBullets[i].y>768) enemyBullets.splice(i,1);
  }

  // Bullet vs enemy
  for(var i=bullets.length-1;i>=0;i--){
    var b = bullets[i];
    var hit = false;
    for(var j=0;j<enemies.length;j++){
      var e = enemies[j];
      if(!e.alive) continue;
      if(boxHit(b.x,b.y,4,8, e.x,e.y,e.w,e.h)){
        e.alive=false;
        var pts = [40,30,20,10];
        score += pts[e.row]||10;
        spawnParticles(e.x,e.y,["#f44","#f84","#ff4","#4ff"][e.row],8);
        sfx.enemyHit();
        hit=true;
        break;
      }
    }
    if(hit) bullets.splice(i,1);
  }

  // Bullet vs barriers
  for(var i=bullets.length-1;i>=0;i--){
    var b=bullets[i], removed=false;
    for(var bi=0;bi<barriers.length&&!removed;bi++){
      var bl=barriers[bi];
      for(var bj=0;bj<bl.length;bj++){
        if(!bl[bj].alive) continue;
        if(boxHit(b.x,b.y,4,8, bl[bj].x+2,bl[bj].y+2,4,4)){
          bl[bj].alive=false;
          bullets.splice(i,1);
          removed=true;
          break;
        }
      }
    }
  }

  // Enemy bullets vs barriers
  for(var i=enemyBullets.length-1;i>=0;i--){
    var b=enemyBullets[i], removed=false;
    for(var bi=0;bi<barriers.length&&!removed;bi++){
      var bl=barriers[bi];
      for(var bj=0;bj<bl.length;bj++){
        if(!bl[bj].alive) continue;
        if(boxHit(b.x,b.y,4,8, bl[bj].x+2,bl[bj].y+2,4,4)){
          bl[bj].alive=false;
          enemyBullets.splice(i,1);
          removed=true;
          break;
        }
      }
    }
  }

  // Enemy bullets vs player
  if(player.invuln<=0){
    for(var i=enemyBullets.length-1;i>=0;i--){
      var b = enemyBullets[i];
      if(boxHit(b.x,b.y,4,8, player.x,player.y,player.w,player.h)){
        enemyBullets.splice(i,1);
        lives--;
        player.invuln = 2;
        spawnParticles(player.x,player.y,"#4f8",12);
        sfx.playerHit();
        if(lives<=0){
          state=STATE_OVER;
          if(score>highScore){ highScore=score; localStorage.setItem("si_hi",highScore); }
          sfx.gameOver();
        }
        break;
      }
    }
  }

  // Enemies reaching player level
  for(var i=0;i<enemies.length;i++){
    if(enemies[i].alive && enemies[i].y+enemies[i].h/2 >= player.y-player.h/2){
      state=STATE_OVER;
      if(score>highScore){ highScore=score; localStorage.setItem("si_hi",highScore); }
      sfx.gameOver();
      return;
    }
  }

  // Enemies vs barriers (destroy barrier blocks enemies pass through)
  for(var i=0;i<enemies.length;i++){
    if(!enemies[i].alive) continue;
    var e=enemies[i];
    for(var bi=0;bi<barriers.length;bi++){
      var bl=barriers[bi];
      for(var bj=0;bj<bl.length;bj++){
        if(!bl[bj].alive) continue;
        if(boxHit(e.x,e.y,e.w,e.h, bl[bj].x+2,bl[bj].y+2,4,4)){
          bl[bj].alive=false;
        }
      }
    }
  }

  // UFO
  ufoTimer -= dt;
  if(!ufo && ufoTimer<=0){
    var dir = Math.random()>0.5?1:-1;
    ufo = { x:dir>0?-20:500, y:40, dir:dir, speed:100, points:[50,100,150,300][Math.floor(Math.random()*4)] };
    ufoTimer = 25 + Math.random()*10;
    ufoSfxTimer=0;
  }
  if(ufo){
    ufo.x += ufo.dir * ufo.speed * dt;
    ufoSfxTimer -= dt;
    if(ufoSfxTimer<=0){ sfx.ufoAppear(); ufoSfxTimer=0.3; }
    if(ufo.x<-30 || ufo.x>510) ufo=null;
  }

  // Bullet vs UFO
  if(ufo){
    for(var i=bullets.length-1;i>=0;i--){
      var b=bullets[i];
      if(boxHit(b.x,b.y,4,8, ufo.x,ufo.y,32,12)){
        score += ufo.points;
        spawnParticles(ufo.x,ufo.y,"#f0f",10);
        sfx.ufoHit();
        // Show points briefly
        particles.push({x:ufo.x,y:ufo.y-10,vx:0,vy:-30,life:1.0,color:"#ff0",text:""+ufo.points});
        ufo=null;
        bullets.splice(i,1);
        break;
      }
    }
  }

  // Particles
  for(var i=particles.length-1;i>=0;i--){
    var p=particles[i];
    p.x+=p.vx*dt;
    p.y+=p.vy*dt;
    p.life-=dt;
    if(p.life<=0) particles.splice(i,1);
  }

  // High score
  if(score>highScore){ highScore=score; localStorage.setItem("si_hi",highScore); }
}

// ── Draw ──
function draw(){
  ctx.clearRect(0,0,W,H);

  // Stars
  drawStars();

  if(state===STATE_START){
    // Title screen
    ctx.save();
    ctx.textAlign="center";
    ctx.fillStyle="#0f0";
    ctx.font="bold "+Math.floor(36*SCALE)+"px monospace";
    ctx.fillText("SPACE INVADERS", W/2, H*0.3);
    ctx.fillStyle="#fff";
    ctx.font=Math.floor(14*SCALE)+"px monospace";
    ctx.fillText("PRESS ENTER OR TAP TO START", W/2, H*0.42);
    ctx.fillStyle="#888";
    ctx.font=Math.floor(12*SCALE)+"px monospace";
    ctx.fillText("ARROWS / A,D = MOVE    SPACE = FIRE", W/2, H*0.50);
    ctx.fillText("USE ON-SCREEN BUTTONS ON MOBILE", W/2, H*0.54);
    // Draw sample enemies
    var sampleY = H*0.65;
    var pts = ["= 40 PTS","= 30 PTS","= 20 PTS","= 10 PTS"];
    var colors = ["#4ff","#ff4","#f84","#f44"];
    for(var r=0;r<4;r++){
      ctx.fillStyle=colors[r];
      ctx.fillRect(W*0.3, sampleY+r*24*SCALE, 12*SCALE, 10*SCALE);
      ctx.fillStyle="#aaa";
      ctx.font=Math.floor(12*SCALE)+"px monospace";
      ctx.fillText(pts[r], W*0.58, sampleY+r*24*SCALE+10*SCALE);
    }
    if(highScore>0){
      ctx.fillStyle="#ff0";
      ctx.font=Math.floor(13*SCALE)+"px monospace";
      ctx.fillText("HIGH SCORE: "+highScore, W/2, H*0.88);
    }
    ctx.restore();
    return;
  }

  // Barriers
  drawBarriers();

  // Enemies
  for(var i=0;i<enemies.length;i++){
    if(enemies[i].alive) drawEnemy(enemies[i]);
  }

  // Player
  if(state===STATE_PLAYING){
    if(player.invuln<=0 || Math.floor(player.invuln*10)%2===0){
      drawPlayer(player.x, player.y);
    }
  }

  // Bullets
  ctx.fillStyle="#fff";
  for(var i=0;i<bullets.length;i++){
    ctx.fillRect((bullets[i].x-1.5)*SCALE, bullets[i].y*SCALE, 3*SCALE, 10*SCALE);
  }

  // Enemy bullets
  ctx.fillStyle="#f44";
  for(var i=0;i<enemyBullets.length;i++){
    ctx.fillRect((enemyBullets[i].x-1.5)*SCALE, enemyBullets[i].y*SCALE, 3*SCALE, 10*SCALE);
  }

  // UFO
  if(ufo) drawUfo(ufo);

  // Particles
  for(var i=0;i<particles.length;i++){
    var p=particles[i];
    if(p.text){
      ctx.fillStyle=p.color;
      ctx.font="bold "+Math.floor(14*SCALE)+"px monospace";
      ctx.textAlign="center";
      ctx.globalAlpha=p.life;
      ctx.fillText(p.text, p.x*SCALE, p.y*SCALE);
      ctx.globalAlpha=1;
      ctx.textAlign="left";
    } else {
      ctx.fillStyle=p.color;
      ctx.globalAlpha=p.life*2;
      ctx.fillRect(p.x*SCALE, p.y*SCALE, 3*SCALE, 3*SCALE);
      ctx.globalAlpha=1;
    }
  }

  // HUD
  ctx.save();
  // Score
  ctx.textAlign="center";
  ctx.fillStyle="#fff";
  ctx.font="bold "+Math.floor(18*SCALE)+"px monospace";
  ctx.fillText(""+score, W/2, 28*SCALE);
  // Wave
  ctx.fillStyle="#888";
  ctx.font=Math.floor(11*SCALE)+"px monospace";
  ctx.fillText("WAVE "+wave, W/2, 44*SCALE);
  // High score
  ctx.textAlign="right";
  ctx.fillStyle="#888";
  ctx.font=Math.floor(11*SCALE)+"px monospace";
  ctx.fillText("HI "+highScore, (480-12)*SCALE, 20*SCALE);
  // Lives
  ctx.textAlign="left";
  for(var i=0;i<lives;i++){
    drawPlayer(20+i*28, 20);
  }
  ctx.restore();

  // Game over overlay
  if(state===STATE_OVER){
    ctx.fillStyle="rgba(0,0,0,0.65)";
    ctx.fillRect(0,0,W,H);
    ctx.textAlign="center";
    ctx.fillStyle="#f44";
    ctx.font="bold "+Math.floor(32*SCALE)+"px monospace";
    ctx.fillText("GAME OVER", W/2, H*0.38);
    ctx.fillStyle="#fff";
    ctx.font=Math.floor(16*SCALE)+"px monospace";
    ctx.fillText("SCORE: "+score, W/2, H*0.47);
    ctx.fillStyle="#ff0";
    ctx.font=Math.floor(14*SCALE)+"px monospace";
    ctx.fillText("HIGH SCORE: "+highScore, W/2, H*0.53);
    ctx.fillStyle="#aaa";
    ctx.font=Math.floor(13*SCALE)+"px monospace";
    ctx.fillText("PRESS ENTER OR TAP", W/2, H*0.62);
    ctx.fillText("TO PLAY AGAIN", W/2, H*0.66);
    ctx.textAlign="left";
  }
}

// ── Game loop ──
var lastTime = 0;
function loop(time){
  var dt = Math.min((time - lastTime)/1000, 0.05);
  lastTime = time;
  update(dt);
  draw();
  requestAnimationFrame(loop);
}
requestAnimationFrame(function(t){ lastTime=t; loop(t); });

})();
</script>
</body>
</html>
